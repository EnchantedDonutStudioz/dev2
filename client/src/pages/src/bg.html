<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<style>
			:root {
				--bg: #06070a;
				--ui-bg: rgba(15, 16, 25, 0.65);
				--ui-fg: #cfe7ff;
			}

			html,
			body {
				height: 100%;
			}

			body {
				margin: 0;
				background: var(--bg);
				overflow: hidden;
				font-family:
					system-ui,
					-apple-system,
					Segoe UI,
					Roboto,
					Inter,
					Arial,
					sans-serif;
			}

			#scene {
				position: fixed;
				inset: 0;
				width: 100vw;
				height: 100vh;
				display: block;
				background: radial-gradient(
						1200px 800px at 70% 35%,
						#0a0f2a 0%,
						#070a17 35%,
						#06070a 70%
					),
					#06070a;
			}

			.blob {
				mix-blend-mode: screen;
			}

			.vignette {
				position: fixed;
				inset: 0;
				pointer-events: none;
				background: radial-gradient(
					120vmax 90vmax at 50% 50%,
					rgba(0, 0, 0, 0) 60%,
					rgba(0, 0, 0, 0.6) 100%
				);
			}

			.controls {
				position: fixed;
				right: 14px;
				top: 14px;
				z-index: 10;
				padding: 10px 12px;
				background: var(--ui-bg);
				backdrop-filter: blur(8px);
				border: 1px solid rgba(255, 255, 255, 0.15);
				border-radius: 10px;
				color: var(--ui-fg);
				font-size: 12px;
				line-height: 1.2;
			}

			.controls label {
				display: block;
				margin-bottom: 6px;
			}

			.controls input[type="range"] {
				width: 200px;
			}

			@media (prefers-reduced-motion: reduce) {
				.blob animate,
				.blob animateTransform {
					display: none;
				}
			}
		</style>
	</head>

	<body>
		<svg
			id="scene"
			viewBox="0 0 1600 900"
			preserveAspectRatio="xMidYMid slice"
			data-quality="medium">
			<defs>
				<filter
					id="softGlow"
					x="-120%"
					y="-120%"
					width="340%"
					height="340%">
					<feGaussianBlur in="SourceGraphic" stdDeviation="4"
					></feGaussianBlur>
				</filter>
			</defs>
			<g id="blobs"></g>
		</svg>

		<div class="vignette"></div>

		<script lang="js">
			const svg = document.getElementById("scene");
			const layer = document.getElementById("blobs");

			let SPEED = parseFloat(0.2);

			const QUALITY = "eco";
			const PRESETS = {
				normal: {
					count: 4,
					points: 8,
					baseDur: 22,
					rMin: 300,
					rMax: 420,
					wobble: 0.6,
					frames: 14,
					minOverlap: 0.58,
				},
				low: {
					count: 3,
					points: 7,
					baseDur: 20,
					rMin: 3000,
					rMax: 420,
					wobble: 0.4,
					frames: 13,
					minOverlap: 0.58,
				},
				eco: {
					count: 3,
					points: 6,
					baseDur: 18,
					rMin: 300,
					rMax: 420,
					wobble: 0.4,
					frames: 12,
					minOverlap: 0.58,
				},
			};
			const P = PRESETS[QUALITY] || PRESETS.medium;

			const PALETTES = [
				[
					["#0B1C8C", "#1232E0", "#2B8FFF", "#82F0FF"],
					["#08145C", "#0E1E8A", "#254AD1", "#66C6FF"],
					["#05103F", "#0C2A85", "#2378FF", "#7DE0FF"],
					["#06243B", "#0C4B64", "#15A4B9", "#9EF5FF"],
					["#0A2742", "#0D5A6E", "#19C38B", "#B2FFD6"],
				],
				[
					["#8c0b0b", "#e01212", "#ff4b2b", "#ffa3a0"],
					["#ff0000", "#c92525", "#ffba71", "#fff98b"],
					["#ff0000", "#c92525", "#ffa571", "#fff98b"],
					["#ff8800", "#c98725", "#ffe571", "#fff98b"],
				],
			];

			const TAU = Math.PI * 2;
			const rand = (a, b) => a + Math.random() * (b - a);

			function wobble(theta, t, seed) {
				const a = Math.sin(theta + t + seed * 1.37);
				const b = Math.sin(theta * 2.17 - t * 0.7 + seed * 0.63);
				const c = Math.sin(theta * 3.41 + t * 1.4 + seed * 2.11);
				return (a + 0.6 * b + 0.35 * c) / 1.95;
			}

			function closedSplinePath(points, tension = 1) {
				const n = points.length,
					p = points;
				let d = `M ${p[0].x.toFixed(2)} ${p[0].y.toFixed(2)} `;
				for (let i = 0; i < n; i++) {
					const p0 = p[(i - 1 + n) % n];
					const p1 = p[i];
					const p2 = p[(i + 1) % n];
					const p3 = p[(i + 2) % n];
					const c1x = p1.x + ((p2.x - p0.x) / 6) * tension;
					const c1y = p1.y + ((p2.y - p0.y) / 6) * tension;
					const c2x = p2.x - ((p3.x - p1.x) / 6) * tension;
					const c2y = p2.y - ((p3.y - p1.y) / 6) * tension;
					d += `C ${c1x.toFixed(2)} ${c1y.toFixed(2)}, ${c2x.toFixed(2)} ${c2y.toFixed(2)}, ${p2.x.toFixed(2)} ${p2.y.toFixed(2)} `;
				}
				return d + "Z";
			}

			function makeShape(cx, cy, r, pts, amp, phase, seed) {
				const arr = [];
				for (let i = 0; i < pts; i++) {
					const th = (i / pts) * TAU;
					const n = wobble(th, phase, seed);
					const rad = r + amp * n;
					arr.push({
						x: cx + Math.cos(th) * rad,
						y: cy + Math.sin(th) * rad,
					});
				}
				return closedSplinePath(arr, 1);
			}

			function createGradient(svg, id, colors) {
				const grad = document.createElementNS(
					"http://www.w3.org/2000/svg",
					"radialGradient",
				);
				grad.setAttribute("id", id);
				grad.setAttribute("gradientUnits", "objectBoundingBox");
				const stops = [
					{off: "0%", a: 1.0},
					{off: "35%", a: 0.95},
					{off: "75%", a: 0.85},
					{off: "100%", a: 0.78},
				];
				colors.forEach((c, i) => {
					const s = document.createElementNS(
						"http://www.w3.org/2000/svg",
						"stop",
					);
					s.setAttribute(
						"offset",
						stops[i]?.off ?? `${(i / (colors.length - 1)) * 100}%`,
					);
					s.setAttribute("stop-color", c);
					s.setAttribute("stop-opacity", stops[i]?.a ?? 0.85);
					grad.appendChild(s);
				});
				svg.querySelector("defs").appendChild(grad);
				return grad;
			}

			function mkLinearAnim(attr, values, dur, keyTimes) {
				const a = document.createElementNS(
					"http://www.w3.org/2000/svg",
					"animate",
				);
				a.setAttribute("attributeName", attr);
				a.setAttribute("values", values.join(";"));
				a.setAttribute("dur", `${dur}s`);
				a.setAttribute("repeatCount", "indefinite");
				a.setAttribute("begin", "0s");
				a.setAttribute("calcMode", "linear");
				if (keyTimes) a.setAttribute("keyTimes", keyTimes);
				return a;
			}

			function pickSpawnPosition(
				W,
				H,
				r,
				existing,
				minOverlapRatio,
				extraGapPx,
			) {
				function candidate() {
					const zone = Math.random();
					if (zone < 0.2)
						return {
							x: rand(-0.05, 0.18) * W,
							y: rand(0.1, 0.9) * H,
						};
					if (zone < 0.4)
						return {x: rand(0.82, 1.1) * W, y: rand(0.1, 0.9) * H};
					if (zone < 0.6)
						return {
							x: rand(0.15, 0.85) * W,
							y: rand(-0.18, 0.12) * H,
						};
					if (zone < 0.8)
						return {
							x: rand(0.15, 0.85) * W,
							y: rand(0.88, 1.15) * H,
						};
					return {x: rand(0.2, 0.8) * W, y: rand(0.25, 0.75) * H};
				}

				const maxTries = 300;
				for (let k = 0; k < maxTries; k++) {
					const c = candidate();
					let ok = true;
					for (const e of existing) {
						const dx = c.x - e.x,
							dy = c.y - e.y;
						const dist = Math.hypot(dx, dy);
						const minDist =
							(r + e.r) * minOverlapRatio + extraGapPx;
						if (dist < minDist) {
							ok = false;
							break;
						}
					}
					if (ok) return c;
				}

				for (let k = 0; k < maxTries; k++) {
					const c = candidate();
					let ok = true;
					for (const e of existing) {
						const dx = c.x - e.x,
							dy = c.y - e.y;
						const dist = Math.hypot(dx, dy);
						const minDist =
							(r + e.r) * (minOverlapRatio - 0.08) +
							Math.max(0, extraGapPx - 10);
						if (dist < minDist) {
							ok = false;
							break;
						}
					}
					if (ok) return c;
				}

				return candidate();
			}

			function createBlob(index, W, H) {
				const g = document.createElementNS(
					"http://www.w3.org/2000/svg",
					"g",
				);
				g.setAttribute("class", "blob");

				const palette =
					PALETTES[localStorage.getItem("theme") || 0][
						Math.floor(
							Math.random() *
								PALETTES[localStorage.getItem("theme") || 0]
									.length,
						)
					];

				const r = rand(P.rMin, P.rMax);
				const pts = P.points;
				const amp = r * P.wobble;
				const seed = Math.random() * 1000;

				return {node: g, palette, r, pts, amp, seed};
			}

			function finalizeBlob(blob, idx, cxBase, cyBase, W, H) {
				const {node: g, palette, r, pts, amp, seed} = blob;

				const dx = rand(
					Math.min(28, W * 0.02),
					Math.min(56, W * 0.035),
				);
				const dy = rand(
					Math.min(20, H * 0.02),
					Math.min(40, H * 0.035),
				);

				const frames = P.frames;
				const dVals = [];
				const keyTimes = Array.from({length: frames + 1}, (_, i) =>
					(i / frames).toFixed(4),
				).join(";");

				const gradId = `grad-${idx}-${Math.random().toString(36).slice(2, 7)}`;
				createGradient(svg, gradId, palette);

				for (let i = 0; i < frames; i++) {
					const t = i / frames;
					const ang = t * TAU;
					const cx = cxBase + Math.cos(ang) * dx;
					const cy = cyBase + Math.sin(ang) * dy;

					const wobPhase = t * TAU;
					dVals.push(makeShape(cx, cy, r, pts, amp, wobPhase, seed));
				}

				dVals.push(dVals[0]);

				const glow = document.createElementNS(
					"http://www.w3.org/2000/svg",
					"path",
				);
				glow.setAttribute("fill", `url(#${gradId})`);
				glow.setAttribute("opacity", "0.85");
				glow.setAttribute("d", dVals[0]);
				glow.setAttribute("filter", "url(#softGlow)");
				glow.appendChild(
					mkLinearAnim("d", dVals, P.baseDur / SPEED, keyTimes),
				);

				const body = document.createElementNS(
					"http://www.w3.org/2000/svg",
					"path",
				);
				body.setAttribute("fill", `url(#${gradId})`);
				body.setAttribute("d", dVals[0]);
				body.appendChild(
					mkLinearAnim("d", dVals, P.baseDur / SPEED, keyTimes),
				);

				const rim = document.createElementNS(
					"http://www.w3.org/2000/svg",
					"path",
				);
				rim.setAttribute("fill", "none");
				rim.setAttribute("stroke", palette[3]);
				rim.setAttribute("stroke-linejoin", "round");
				rim.setAttribute("opacity", "0.14");
				rim.setAttribute("stroke-width", Math.max(2, r * 0.02));
				rim.setAttribute("d", dVals[0]);
				rim.appendChild(
					mkLinearAnim("d", dVals, P.baseDur / SPEED, keyTimes),
				);

				g.appendChild(glow);
				g.appendChild(body);
				g.appendChild(rim);
				layer.appendChild(g);
			}

			function setup() {
				const W = svg.clientWidth;
				const H = svg.clientHeight;
				svg.setAttribute("viewBox", `0 0 ${W} ${H}`);
				layer.innerHTML = "";

				const blobs = Array.from({length: P.count}, (_, i) =>
					createBlob(i, W, H),
				);

				const placed = [];
				for (let i = 0; i < blobs.length; i++) {
					const b = blobs[i];

					const extraGap = Math.min(W, H) * 0.05;
					const spawn = pickSpawnPosition(
						W,
						H,
						b.r,
						placed,
						P.minOverlap,
						extraGap,
					);
					placed.push({x: spawn.x, y: spawn.y, r: b.r});
				}

				for (let i = 0; i < blobs.length; i++) {
					finalizeBlob(blobs[i], i, placed[i].x, placed[i].y, W, H);
				}
			}

			function setSpeed(s) {
				SPEED = Math.max(0.1, parseFloat(s) || 1);

				setup();
			}

			window.addEventListener("resize", setup);

			setup();
		</script>
	</body>
</html>
